# Cloud-native patterns: Immutability and loose coupling

In the course of this lab and the following ones we will gradually improve our rudimentary SplitDim web app into a fully fledged cloud native app that is stateless, scalable and resilient. Recall, SplitDim helps groups of people keep track of money transfers between themselves and clear debts. 

![SplitDim logo, generated by logoai.com.](/99-labs/fig/splitdim-logo.png)

Currently the app uses a local database maintained in memory: we know that this is not safe under scaling and restarting pods. The below tasks guide you in making the web app stateless by state externalization. The tasks are followed by tests; absolve each to complete the lab.

## Table of Contents

1. [Preliminaries](#preliminaries)
2. [A key-value store client](#a-key-value-store-client)
3. [A persistent datalayer](#a-key-value-store-datalayer)
4. [Loose coupling](#loose-coupling)

## Preliminaries

Recall, SplitDim is a web app that lets groups of people keep track of who owns who. The web service implements the following API endpoints:
- `GET: /`: a static HTML/JS artifact that you can use to interact with the app from a browser,
- `POST: /api/transfer`: register a transfer between two users of a given amount,
- `GET: /api/accounts`: return the list of current balances for each registered user,
- `GET: /api/clear`: return the list of transfers that would allow users to clear their debts, and
- `GET: /api/reset`: reset all balances to zero.

The data layer is currently rather primitive, maintaining the entire account database in memory:

``` go
type Account struct {
    // The name of the account holder.
    Holder string `json:"holder"`
    // Current balance.
    Balance int `json:"balance"`
}

type localDB struct {
    // accounts maintains the balance for each user name
    accounts map[string]int
    // The read-write mutex makes sure concurrent access is safe.
    mu sync.RWMutex
}

// NewDataLayer creates a new database of accounts.
func NewDataLayer() api.DataLayer {
    return &localDB{accounts: make(map[string]int)}
}
```

This is not ideal for a number of reasons:
- first, pods in Kubernetes are ephemeral: once the `splitdim` Deployment is restarted for some reason all internal state of all the pods, together with the account database, is lost (*persistence*),
- second, we cannot scale the web app, as the accounts database would then be split across the pods' in-memory databases, leading to inconsistent state (*scalability*).

Cloud native apps are, in contrast, stateless, storing all *resource state* in a safe persistent external database (*immutability*). We provide a barebones key-value store called `KVstore` (see `/99-labs/code/kvstore`) for this purpose. The key-value store exposes a simple API:
- the database stores a list of key-value pairs, where keys are represented as strings and value are represented as versioned strings; recall, versions are used to ensure eventual consistency:
  ```go
  type VersionedKeyValue struct {
      Key string `json:"key"`
      VersionedValue
  }

  type VersionedValue struct {
      Value   string `json:"value"`
      Version int    `json:"version"`
  }
  ```
- `POST: /api/get, body: "key"`: get versioned value for the key given in the HTTP request body;
- `POST: /api/put, body: {"key":"key", "value":"value", "version":version}`: insert the key-value pair (only if the current version equals the specified version);
- `GET: /api/reset`: remove all key-value pairs from the store;
- `GET: /api/list`: list the stored versioned key-value pairs.

The key-value store persists the store into a transaction log that is by default created at `/tmp/translog.log` and restores the store on startup from the persisted log.

Make sure to familiarize yourself with the workings of `kvstore`: 
- start the key-value store: the server will listen at `localhost:8081`:
  ```shell
  cd /99-labs/code/kvstore
  go run kvstore.go 
  ```
- insert the key-value pair `key1=1` at version 0 into the store:
  ```shell
  curl -X POST -H "Content-Type: application/json" --data '{"key":"key1","value":"1","version":0}' http://localhost:8081/api/put
  ```
- reinserting the same key with a different value `key1=2` at the same version 0 will fail, since the version in the store is now 1:
  ```shell
  curl -i -X POST -H "Content-Type: application/json" --data '{"key":"key1","value":"2","version":0}' http://localhost:8081/api/put
  HTTP/1.1 428 Precondition Required
  ```
- query the currently stored value and version in the database for `key1`:
  ```shell
  curl -X POST -H "Content-Type: application/json" --data '"key1"' http://localhost:8081/api/get
  {"value":"1","version":1}
  ```
- insert the new value with the new version and then list the entire content of the database:
  ``` shell
  curl -i -X POST -H "Content-Type: application/json" --data '{"key":"key1","value":"2","version":1}' http://localhost:8081/api/put
  curl --request GET http://localhost:8081/api/list
  [{"key":"key1","value":"2","version":2}]
  ```
- restarting the key-value store will restore the database from the transaction log
  ```shell
  ^-C
  go run kvstore.go 
  kvstore.go:120: Using transaction log in "/tmp/translog.log"
  filelog.go:26: Opening/creating transaction log in file /tmp/translog.log
  Read-events: New event transactionlog.Event{Sequence:0x1, Type:"put", Value:"{\"key\":\"key1\",\"value\":\"1\",\"version\":0}"}
  Read-events: New event transactionlog.Event{Sequence:0x2, Type:"put", Value:"{\"key\":\"key1\",\"value\":\"2\",\"version\":1}"}
  kvstore.go:183: Starting HTTP server at :8081
  ```
- clear the database:
  ```shell
  curl --request GET http://localhost:8081/api/reset
  ```

# A key-value store client

# A key-value store datalayer

So let us write a Redis datalayer for our web app.

1. Enter the directory under `99-labs/code/splitdim` for our Go project from the previous lab. Make sure all tests pass at this point.

2. Since we are going to implement multiple datalayers side by side, we need a way for the user to select among them (*manageability*) when starting the app. We will use two environment variables for that purpose:

   ``` go
   // KVStoreMode defines the data layer mode (local/redis/kvstore).
   var KVStoreMode = "local"
   
   // KVStoreAddr stores the key-value store address as a DNS domain name or IP address.
   var KVStoreAddr = "localhost:8001"
   ```

   Then, as the `main` function starts we read the environment variables and initialize the datalayer based on the current setting. 
   
   ``` go
   var db api.DataLayer

   func main() {
       
       if os.Getenv("KVSTORE_MODE") != "" {
           KVStoreMode = os.Getenv("KVSTORE_MODE")
       }
       if os.Getenv("KVSTORE_ADDR") != "" {
           KVStoreAddr = os.Getenv("KVSTORE_ADDR")
       }
       
       switch KVStoreMode {
       case "kvstore":
           log.Printf("Using the kvstore datalayer using kvstore %q", KVStoreAddr)
           db = kvstore.NewDataLayer(KVStoreAddr)
       case "local":
           fallthrough
       default:
           log.Println("Using the local datalayer")
           db = local.NewDataLayer()
       }
       ...
   }
   ```
   
   The `local` datalayer will start as default, but starting the app with `KVSTORE_MODE=kvstore` will start the key-value store datalyer )once we write it).



> âœ… **Check**
> 
> Test your Kubernetes deployment. 

<!-- Local Variables: -->
<!-- mode: markdown; coding: utf-8 -->
<!-- auto-fill-mode: nil -->
<!-- visual-line-mode: 1 -->
<!-- markdown-enable-math: t -->
<!-- End: -->
