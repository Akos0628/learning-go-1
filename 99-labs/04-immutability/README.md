# Cloud-native patterns: Immutability and loose coupling

In the course of this lab and the following we will gradually improve the our rudimentary SplitDim web app into a dully fledged cloud native app. Recall, SplitDim helps groups of people to keep track of money transfers between themselves and clear debs. Currently the app uses a local database maintained in memory: we know that this is not safe under scaling and restarting pods.

![SplitDim logo, generated by logoai.com.](/99-labs/fig/splitdim-logo.png)

The below tasks guide you in making our web app stateless by adding state externalization to the app. The tasks are followed by tests; absolve each to check whether you successfully completed the lab.

## Table of Contents

1. [Preliminaries](#preliminaries)
1. [A key-value store datalayer](#a-key-value-store-datalayer)
2. [A generic key-value store client](#a-generic-key-value-store-client)
3. [Loose coupling](#loose-coupling)

## Preliminaries

Recall, SplitDim is a web app that lets groups of people to keep track of who owns who. The web service will implement 4 APIs:
- `POST: /api/transfer`: register a transfer between two users of a given amount,
- `GET: /api/accounts`: return the list of current balances for each registered user,
- `GET: /api/clear`: return the list of transfers that would allow users to clear their debts, and
- `GET: /api/reset`: reset all balances to zero.

The data layer is currently rather primitive, maintaining the entire account database in memory:

``` go
type Account struct {
    // The name of the account holder.
    Holder string `json:"holder"`
    // Current balance.
    Balance int `json:"balance"`
}

type localDB struct {
	// accounts maintains the balance for each user name
	accounts map[string]int
	// The read-write mutex makes sure concurrent access is safe.
	mu sync.RWMutex
}

// NewDataLayer creates a new database of accounts.
func NewDataLayer() api.DataLayer {
	return &localDB{accounts: make(map[string]int)}
}
```

This is not ideal for a number of reasons:
- first, pods in Kubernetes are ephemeral: once a Deployment is restarted for some reason all internal state of all the pods is lost (*persistence*),
- second, we cannot scale the web app, as the accounts database would then be split across the pods' in-memory databases, leading to inconsistent state (*scalability*).

Cloud native apps are, in contrast, stateless, storing all *resource state* in a safe persistent external database (*immutability*). We included an extremely simple key-value store called `KVstore` (see `/99-labs/code/kvstore` for this purpose). The key-value store exposes an extremely simple API:
- values are represented as a versioned string to ensure eventual consistency:
  ```go
  type VersionedValue struct {
      Value   string `json:"value"`
      Version int    `json:"version"`
  }
  ```
- keys are also strings, values are versioned strings:
  ``` go
  type VersionedKeyValue struct {
      Key string `json:"key"`
      VersionedValue
  }
  ```
- `GET /api/reset`: remove all key-value pairs,
- `POST /api/get, body: "key"`: get versioned value for the key given in the HTTP request body,
- `POST /api/put, body: versioned-key-value`: insert the key-value pair if the current version equals the specified version,
- `GET /api/list`: list the stored versioned key-value pairs.

The key-value store persists the store into a transaction log that is by default created at `/tmp/translog.log` and restores the store on startup from the persisted log.

Make sure to familiarize yourself with the workings of `kvstore`: 
- start the key-value store: the server will listen at `localhost:8081`:
  ```shell
  cd /99-labs/code/kvstore
  go run kvstore.go 
  ```
- insert the key-value pair `key1=1` at version 0 into the store:
  ```shell
  curl -X POST -H "Content-Type: application/json" --data '{"key":"key1","value":"1","version":0}' http://localhost:8081/api/put
  ```
- reinserting the same key with a different value `key1=2` at the same version 0 will fail, since the version in the store is now 1:
  ```shell
  curl -i -X POST -H "Content-Type: application/json" --data '{"key":"key1","value":"2","version":0}' http://localhost:8081/api/put
  HTTP/1.1 428 Precondition Required
  ```
- query the currently stored value and version in the database for `key1`:
  ```shell
  curl -X POST -H "Content-Type: application/json" --data '"key1"' http://localhost:8081/api/get
  {"value":"1","version":1}
  ```
- insert the new value with the new version and list the database:
  ``` shell
  curl -i -X POST -H "Content-Type: application/json" --data '{"key":"key1","value":"2","version":1}' http://localhost:8081/api/put
  curl --request GET http://localhost:8081/api/list
  [{"key":"key1","value":"2","version":2}]
  ```
- restarting the key-value store will restore the database from the transaction log
  ```shell
  ^-C
  go run kvstore.go 
  kvstore.go:120: Using transaction log in "/tmp/translog.log"
  filelog.go:26: Opening/creating transaction log in file /tmp/translog.log
  Read-events: New event transactionlog.Event{Sequence:0x1, Type:"put", Value:"{\"key\":\"key1\",\"value\":\"1\",\"version\":0}"}
  Read-events: New event transactionlog.Event{Sequence:0x3, Type:"put", Value:"{\"key\":\"key1\",\"value\":\"2\",\"version\":1}"}
  kvstore.go:183: Starting HTTP server at :8081
  ```
- clear the database:
  ```shell
  curl --request GET http://localhost:8081/api/reset
  ```

# A key-value store datalayer

So let us write a Redis datalayer for our web app.

1. Enter the directory under `99-labs/code/splitdim` for our Go project from the previous lab. Make sure all tests pass at this point.

2. Since we are going to implement multiple datalayers side by side, we need a way for the user to select among them (*manageability*) when starting the app. We will use two environment variables for that purpose:

   ``` go
   // KVStoreMode defines the data layer mode (local/redis/kvstore).
   var KVStoreMode = "local"
   
   // KVStoreAddr stores the key-value store address as a DNS domain name or IP address.
   var KVStoreAddr = "localhost:8001"
   ```

   Then, as the `main` function starts we read the environment variables and initialize the datalayer based on the current setting. 
   
   ``` go
   var db api.DataLayer

   func main() {
       
       if os.Getenv("KVSTORE_MODE") != "" {
           KVStoreMode = os.Getenv("KVSTORE_MODE")
       }
       if os.Getenv("KVSTORE_ADDR") != "" {
           KVStoreAddr = os.Getenv("KVSTORE_ADDR")
       }
       
       switch KVStoreMode {
       case "kvstore":
           log.Printf("Using the kvstore datalayer using kvstore %q", KVStoreAddr)
           db = kvstore.NewDataLayer(KVStoreAddr)
       case "local":
           fallthrough
       default:
           log.Println("Using the local datalayer")
           db = local.NewDataLayer()
       }
       ...
   }
   ```
   
   The `local` datalayer will start as default, but starting the app with `KVSTORE_MODE=kvstore` will start the key-value store datalyer )once we write it).



> âœ… **Check**
> 
> Test your Kubernetes deployment. 

<!-- Local Variables: -->
<!-- mode: markdown; coding: utf-8 -->
<!-- auto-fill-mode: nil -->
<!-- visual-line-mode: 1 -->
<!-- markdown-enable-math: t -->
<!-- End: -->
